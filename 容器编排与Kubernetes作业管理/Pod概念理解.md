## Pod概念理解

通过前面的学习我们知道，其实容器本质上是一个进程，是一个特殊的进程。  
其与其他容器通过Linux Namespace进行隔离，通过Cgroup对进程的资源进行限制  
同时将基础镜像的rootfs挂载到容器进程对应的根目录下，由于mount Namespace（修改进程的文件视图），所以在对应的进程里看到的就是挂载后的文件视图。    
	
**pod其实就是容器组，为什么会有容器组的概念？**   
	
我们考虑一个场景，当我们的业务需求需要我们将两个容器调度在同一个节点上时，   
比如容器1产生内容写入某个文件，容器2从对应文件读取内容进行显示。再比如，如果两个容器需要使用localhost通信或者socket通信。    
	
从上面可以看出这种关系比较密切的容器其实是需要共享一些namespace的，比如网络、mount等，同时我们能需要一种机制保证这些容器可以调度到同一个节点。其实这就是pod的本质，pod是一个逻辑概念，同一个pod中的容器共享了mount、network、uts namespace，并且pod内容器可以保证调度到同一个节点。    
	

> 如何保证两个容器调度到同一个节点？很直观的一个想法就是在同一个节点上运行命令  
> docker run --net=B --volumes-from=B --name=A --image =A  
> 	
> 但是这样同样会有问题，那就是本质上AB两个容器是对等的，现在就导致AB启动会有先后顺序，这样就成了一个拓扑结构  
> 	
> Kubenetes采用了如下的处理方式，每次调度一个pod到对应的node时，会先启动一个infra容器，infra容器是一个很简单的容器，其基础镜像是由汇编语言写的，大小也不过只有几十K，目的就是为pod提供linux namespace的环境，这样pod中其他容器就可以通过如上的方式共享infra容器的namespace，pod生命周期只与infra容器有关，并且我们可以理解为pod的流量进出都是通过infra容器。

​	

考虑两个场景实例：

- 一个java web的jar包，想要放在tomcat的webapps目录下运行，一个解决思路是我们把jar包放在tomcat对应路径下，出一个新的镜像，但是这种其实是比较繁琐的，需要重新打包出镜像。另外一个解决思路是在一个pod中运行两个容器，tomcat容器